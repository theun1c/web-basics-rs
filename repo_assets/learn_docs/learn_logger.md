### как я писал логгер, не зная раста 
Для создания логгера необходимо как-то вызвать его 1 раз, а использовать множество раз.

Следует использовать какой-либо механизм, похожий на singleton. 

Такой механизм можно реализовать с помощью Oncecell.

OnceCell - это контейнер, который может содержать значение, инициализируемое только один раз. Он потокобезопасен (sync::OnceCell для многопоточности).

Аналогия: Представьте коробку, в которую можно положить что-то только один раз, но доставать можно много раз.

Для начала нужен импорт скаченного через cargo модуля

``` bash
cargo run once_cell
```

``` rust 
use once_cell::sync::OnceCell;  // Для singleton-контейнера 
```

Затем инициализируем логгер 
``` rust
struct Logger {
    // some logic
}

static LOGGER: OnceCell<Logger> = OnceCell::new();
```

Далее происходит очень странный момент, который я не до конца понимаю.

Я говорю про имплементацию impl.

impl - это блок реализации, который привязывает методы к типу (структуре, enum или trait). Это не аналог класса, а механизм для организации кода.

ГПТ накинул мне данный пример:
``` rust
struct Logger {
    filename: String,
}

inpl Logger {
    fn new(name: &str) -> Self {
        Logger{ filename: name.to_string()}
    }

    fn log(&self, msg: &str){
        println!("{}", msg);
    }
}
```

Как я понял, чтобы привязать к структуре какие-либо методы, мне необходимо объявить impl с названием моей структуры. Теперь в теле impl первой функцией будет являться что-то типо "конструктора". 

Но тут еще есть Self. Я пока без понятия что это, но есть догадки, что первая функция конструктор возвращает экземпляр, к которому потом будут "цепляться" сторонние функции. мб я ошибаюсь 

В расте нет ООП, но есть вот такие вот "импортозамещения". 

Вернемся к конструктору. В раст используются ассоциативные функции. От обычного метода они отличаются тем, что в них не передается параметр Self. 

Вот пример
``` rust 
impl Point{
    fn new(x: f64, y: f64) -> Self {
        Point { x, y }
    }

    fn another_fun(&self) -> f64 {
        // ...
    }
}
```

То есть, как я понимаю, первая функция "ассоциативная", может иметь любое имя. Она отвечает за возврат экземпляра структуры или перечисления, которым внутри impl станет Self. Далее используя &self внутри остальных функций, можно "привязать" методы к структуре. 

После отправки моей "мысли", которая описана выше, гпт, он ответил, что я на правильном пути и понял суть (вроде как гпт всегда и везде поддакивает, поэтому я ему не особо верю). Далее буду обрабатывать его "замечания". 

impl - это просто привязка в расте. Импл как бы говорит "эти функции работают с данной структурой".  

Self (с заглавной S) - это псевдоним типа, для которого пишется impl. Это ключевое слово, которое заменяется на имя типа.

А self с маленькой - это уже экземпляр. ну точнее &self принимает экземпляр.

В методах есть 3 вида маленького self: 

&self - неизменяемое заимстрование (чтение)
``` rust
fn get_name(&self) -> &str {
    &self.name // возвращаем ссылку на имя
}

fn check_age(&self) -> bool {
    self.age >= 18 // проверяем но не меняем
}
```

&mut self - изменяемое заимствование (запись)
``` rust
fn rename(&mut self, new_name: &str) {
    self.name = new_name.to_string()
}
```

self - владение (потребление)
``` rust
impl User {
    // Забираем владение структурой, после вызова она уничтожается
    fn consume(self) -> String {
        format!("User {} (age {}) consumed", self.name, self.age)
        // self уничтожается здесь, в конце функции
    }
}

let user = User { name: "Alice".to_string(), age: 25 };
let message = user.consume();  // user больше НЕ существует!
// println!("{}", user.name);  // ❌ ОШИБКА! user перемещен
```

Если не писать self, то это будет ассоциативная функция. 

Методы вызываются через . , а ассоциативные функции через :: 

в impl может быть сколько угодно ассоциативных функций. Это наверно сравнимо с перегрузкой конструктора

После небольшой теории я написал следующий код логгера
``` rust
struct Logger {

}

static LOGGER: OnceCell<Logger> = OnceCell::new();

impl Logger{
    fn new() -> Self {
        Logger {}
    }

    fn log(&self, text: &str, level: &str){
        let time = SystemTime::now();
        println!("{:?} | {} | {}", time, level, text);
    }

    fn error(&self, text: &str) {
        self.log(text, "ERROR");
    }

    fn warn(&self, text: &str){
        self.log(text, "WARN");
    }

    fn success(&self, text: &str){
        self.log(text, "SUCCESS");
    }
}
```

Но теперь нужно как-то получить этот логгер. 

Для этого OnceCell требует написать какой-то публичный геттер логгера. вот пример: 
``` rust
pub fn get_logger() -> &`static Logger {
    LOGGER.get_or_init(|| Logger::new())
}

get_logger().error("error bla bla"); 
```

Появляетсяя кучу вопросов. К примеру что такое возврат &`static и что такое ||...

&'static - это ссылка с временем жизни 'static. То есть & как и в СИ - ссылка на что-то. 

``` rust
// Обычная ссылка - живет недолго
let x = 5;
let r = &x;  // r живет, пока живет x
// r имеет неявное время жизни

// 'static ссылка - живет ВСЮ программу
let s: &'static str = "Hello";  // Строковый литерал живет всегда
static NUM: i32 = 42;  // Статическая переменная
let n: &'static i32 = &NUM;  // Ссылка на статику тоже 'static
```

OnceCell::get_or_init() возвращает &'static T

|| ... - это замыкание (closure) в Rust.

```  rust
// Функция:
fn add(x: i32, y: i32) -> i32 { x + y }

// Замыкание (анонимная функция):
let add = |x: i32, y: i32| -> i32 { x + y };

// Сокращенная форма (типы выводятся):
let add = |x, y| { x + y };
let add = |x, y| x + y;  // Если одно выражение

// Без параметров:
let say_hello = || { println!("Hello!"); };
say_hello();  // Вызов
```

Вот эта публичная функция - ее можно использовать в любом модуле. Она создает логгер и возвращает его. Создает его с помощью замыкания. 

``` rust
pub fn get_logger() -> &'static Logger{
    LOGGER.get_or_init(|| Logger::new())
}
```

Пока что файл логгера выглядит следующим образом 
``` rust

use std::{fs::File, io::Write, time::SystemTime};
use once_cell::sync::OnceCell;

// logger path
const LOGGER_PATH: &str = "./logger/logger_file.txt";

struct Logger {

}

static LOGGER: OnceCell<Logger> = OnceCell::new();

impl Logger{
    fn new() -> Self {
        Logger {}
    }

    fn log(&self, text: &str, level: &str){
        let time = SystemTime::now();
        println!("{:?} | {} | {}", time, level, text);
    }

    fn error(&self, text: &str) {
        self.log(text, "ERROR");
    }

    fn warn(&self, text: &str){
        self.log(text, "WARN");
    }

    fn success(&self, text: &str){
        self.log(text, "SUCCESS");
    }
}

pub fn get_logger() -> &'static Logger{
    LOGGER.get_or_init(|| Logger::new())
}

fn main() { 
    let logger = get_logger();
    logger.error("some error");
}

```

В нем я вижу несколько недочетов. следует сделать функцию log приватной и вместо консольного вывода следует создать вывод в файл. Также стоит изменить вывод времени в нужном мне формате. а еще стоит изменить дерево проекта (вынести логику логгера в другое место). Ну и ридми переработать. 